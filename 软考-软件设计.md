### 加密

对称加密：加密解密的密钥一样，公钥加密，私钥解密，（pdf，excel加密）
非对称：密钥不一样 （RSA），公钥可以随意传播，甲公钥加密，甲公钥解密。速度慢，不适合大量数据
信息摘要：保证信息完整性，无法篡改（算法：单向散列函数，单向hash函数。明文=>摘要，无法逆向）
数字签名：防抵赖，无法保密（发送方正文产生信息摘要用A的私钥加密=>接受方用A的公钥解密得到摘要并用正文产生摘要比对），摘要对称加密
数字信封：（与数字签名对比）用对方的公钥加密，对方可以用私钥解密，更安全
数字证书：传输过程中要证明人的身份，CA颁发数字证书（颁发机构的签名，持有者公钥信息）
设计邮件加密系统：
发送方（公钥：Ea, 私钥：Da）|  接收方（公钥：Eb, 私钥：Db）

邮件正文=>(随机密钥K)邮件密文   |   邮件密文=>（随机密钥K）邮件正文 ，关键是如何传递K
正文=>摘要=>（数字签名Da）摘要密文  |  摘要密文=>(Ea) 邮件摘要，对比正文生成的摘要
K=>(Eb)加密K |  加密K=>(Db)K

### 线性表

-  顺序表 用一维数组存储，连续空间

### 链表
离散空间，一个空间存数据和下一个元素的地址

- 单链表 头到尾
- 循环链表 尾巴指向头部，可以直接next操作到头部
- 双向链表 除了头和尾，中间的元素空间存上一个和下一个空间的地址
结点的删除、插入

### 双端队列

- 一端输入受限的双端队列
- 一端输出受限的双端队列
### 广义表
n个元素组成的有限序列，是线性表的推广
通常用递归的形式进行定义，记作 LS=(a0,a1,a2...,an)
n是长度，是最外层括号中的元素个数，括号重数为深度（嵌套次数）
操作：head(LS),tail(LS)
表头：第一个元素
表尾：除了第一个元素的其他元素组成的广义表

### 树

- 结点的度：孩子结点的数量
- 树的度：结点度数最高的度
- 叶子结点：没有孩子的结点
- 分支结点：有分支的结点
- 内部结点：除根节点和叶子结点
- 父结点：相对与子结点
- 子结点：相对于父结点
- 兄弟结点：相对的
- 层次：
### 二叉树
每个结点最多有2个子结点
1. 在二叉树的第i层上最多有2^(i-1)个结点（i>=1）
2. 深度为k的二叉树最有2^k-1个结点
3. 对于任何一棵二叉树，如果其叶子结点数为n0，度为2的结点数为n2，则n0=n2+1
4. 如果对一棵有n个结点的完全二叉树的结点按层序编号（从第1层到[log2n]+1层，每层从左到右），则对任一结点i(i<=i<=n),有
#### 满二叉树
　除最后一层无任何子[节点](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%25E8%258A%2582%25E7%2582%25B9)外，每一层上的所有结点都有两个子结点二叉树。
　　国内教程定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。
　　国外(国际)定义:a binary tree T is full if each node is either a leaf or possesses exactly two childnodes.大意为：如果一棵二叉树的结点要么是叶子结点，要么它有两个孩子结点，这样的树就是满二叉树。
#### 完全二叉树
1）只允许最后一层有空缺结点且空缺在右边，即叶子结点只能在层次最大的两层上出现；
2）对任一结点，如果其右子树的深度为j，则其左子树的深度必为j或j+1。 即度为1的点只有1个或0个

**满二叉树和完全二叉树编号可以用算法简单求出各个结点**
	  1
	 2     3
	4 5     6
	  7
	   8
层次遍历：按层次从左到右，12345678
前序遍历：先根后左再右，12457836
中序遍历：先左后根再右，42785136
后序遍历：先左后右再根，48752631
拆分子树不断遍历
#### 反向构造二叉树
根据某2个序列构造二叉树
#### 树转二叉树
孩子结点-左子树结点
兄弟结点-右孩子结点
连线法（兄弟结点连接，有多个子节点保留最左边的结点连线，断开其他，再旋转树）
#### 查找二叉树/排序二叉树
所有的左结点小于根结点，右结点大于根结点。有规律的排序可以提高查询速度
#### 最优二叉树（哈夫曼树）
- 树的路径长度 : 连接线的长度和
- 权：结点数值（某种字符出现的频度）
- 带权路径长度  ：结点路径长度x权
- 树的带权路径长度（树的代价）：叶子结点的带权路径长度和，最小则最优（哈夫曼树）`

#### 线索二叉树
普通二叉树叶子结点空了大量指针（没有子结点）
叶子结点加线索指向前驱节点和后驱结点
#### 平衡二叉树
为了提高查找效率。
- 任意结点的左右子树深度相差不超过1
- 没结点的平衡度只能为-1，0，1

树没有环，图有
### 图
- 无向图：连线没有箭头，邻接矩阵存储
- 有向图：连线有箭头，邻接表存储（首先把每个顶点的邻接顶点用链表示出来，然后用一个一维数组来顺序存储上面每个链表的头指针）
- 完全图：在无向图中，每对顶点都有一条线相连。在有向图中，每对顶点之间都有2条有向边互相连接

#### 图的最小生成树-普里姆算法/克鲁斯卡尔算法
边的路径总和最小，且不能形成环

### 算法
- 有穷性：执行有穷步之后结束
- 确定性：每一条指令都必须有确切的含义
- 输入 ：0个或以上的输入
- 输出 ：1个或以上的输出
- 有效性：每个步骤都有有效执行并能得到确定的结果。

#### 时间复杂度
常数级时间复杂度：O(1)
树查找：O(log2^n)
算法循环n次：O(n)
k层循环,每层循环k次：O(n^k)
O(2^n)
 空间复杂度：-

顺序查找：平均查找长度：(1+n)/2，时间复杂度：O(n)级别
二分查找：序列按顺序排列 ：最多次数为 的[log2^n]+1 ，时间复杂度为O(log2^n)
散列表查找：设计hash函数将给出key生成地址。设计一个好的hash函数需要减少冲突。

#### 排序
- 稳定与不稳定排序，稳定排序相同的键值顺序不会随机改变
- 内排序：内存里的排序
- 外排序：涉及到内存外的排序

1. 直接插入排序：插入一个已经排序的序列，一个个比较，找合适的位置
2. 希尔(Shell)插入排序：（分组插入排序），n个元素，d1=n/2(取奇数)，d2=d1/2（取奇数），d3=d2/2（取奇数），直到d3=1，先多几轮排出大致顺序，再在最后一轮彻底排好。
3. 直接选择排序：选出最小的元素与第一个元素交换，再除掉第一个元素外的剩余序列中重复上述过程，直至排序完成。
4. 堆排序（复杂，指利用堆这种数据结构所设计的一种排序算法）：近似完全二叉树的结构，所有孩子结点比父结点大叫小顶堆，所有孩子结点比父结点小叫大顶堆。
	1. 初建堆，R{2，4，5，1，2，3，8，0}序列按顺序一层一层排成完全二叉树，再从非叶子结点中一个个调整（跟最小的孩子结点调换位置），从最后一个非叶子结点开始。
	2. R{80,60,15,50,45,10,15,30,40,20},已经是一个堆了。R序列排成完全二叉树后将最后一个结点（最底层的最右边的结点）替换根节点，然后将根节点与孩子结点比较、交换，直至所有结点都满足完全二叉树。如此完成一轮排序。然后重复上述过程直至完成全部的排序。
5. 冒泡排序：通过相邻元素之间的比较和交换，将排序码较小的元素逐渐从底部移向顶部。最后两个元素比较，将小的排到前面，然后重复此过程，直至最小的元素排到最前，完成一轮排序。重复此过程直至完成所有排序。
6. 快速排序：选取最后一个元素为基准，依次取序列的元素与基准比较，如果比基准大则交换位置，否则将基准的前一个元素设为基准，接着比较。重复上诉过程可以产生一个序列，基准在中间，左边的序列都比基准小，右边的都比基准大。再将两边的序列也按照上诉过程排序顺序（递归）。思想是分治法。
7. 归并排序：将两个或两个以上的有序子表合并成一个新的有序表。一般将2个有序表合并成一个有序表，也称二路合并（操作简单）。
8. 基数排序：适合于元素很多而关键字较少的序列。基数的选择和关键字的分解是根据关键字的类型来决定的，例如关键字是十进制数，则按个位、十位来分解。
![[排序复杂度.png]]

## 程序设计语言与语言处理程序基础
### 编译过程
#### 编译型
源程序->词法分析（正规式，有限自动机）->语法分析（根据语言语法规则）->语义分析（语义检查）->中间代码生成->代码优化->目标代码生成（中间代码转低级语言代码，需要考虑硬件系统结构）->目标程序
## 文法定义
- 语法推导树：

- 彩色空间：
	- RGB（红绿蓝） 配比产生其他颜色
	- YUV(兼容彩色和黑白电视)
	- CMY,CMYK（印刷，吸收其他颜色，反射黄色光，我们就看到黄色）
	- HSV(HSB)
- 图像容量（内存大小）
	- 每个像素为16位，图像为640x480像素，求容量：`640*480*(16/2)=614400B`
	- 640480像素,256色的图像，求容量：`640*480*log2(256)/8=307200B`,256色意味着每个而像素用8位存储
- 音频容量计算
	- `容量=采样频率（Hz）*量化/采样位数（位）*声道数/8`
- 视频容量计算
	- `容量=每帧容量（Byte）*每秒帧数*时间+音频容量*时间`

- 颜色深度24位=3B，
#### 多媒体标识
- jpeg(有损，离散余弦),jpeg-2000(有损&无损)
- mpeg-1(mp3，vcd,离散余弦)
- mpeg-2(DVD)
- mpeg-4,mpeg-7,mpeg-21
#### 数据压缩
- 有损不可以还原，无损可以还原
- 有损压缩比高
- 有损（熵压缩），无损（熵编码）
#### 瀑布模型
- 结构化代表
- 软件计划->需求分析（需求容易变动，实际情况太复杂）->软件设计->程序编码->软件测试->运行维护
- 适合需求明确或二次开发
#### 快速原型模型
- 先做一个原型（简易系统）给用户展示（墨刀等工具），与客户讨论、确认需求
- 应用于需求分析阶段
#### 增量模型
- 先做核心模块，给用户使用、反馈，迭代
#### 螺旋模型
- 组合多个模型
- 引入了风险分析
#### V模型
- 强调测试，及早介入测试
#### 喷泉模型
- 面向对象
- 迭代
- 无间隙
#### RAD
- 快速构建业务系统
#### CBSD
- 需求分析和定义->软件架构设计->构件库的建立->应用软件构建->测试和发布
- 构建库（类似组件）
#### 统一过程（UP）
- 二八定律（80%的时间使用20%的功能）
- 初始（确定项目边界）->细化（建立架构）->构建（开发构件，就是开发阶段）->交付（测试，发布，编写用户手册，培训）
#### 敏捷开发（一组模型）
- 基本原则
	- 短平快的会议
	- 小型版本发布
	- 较少的文档
	- 合作为重
	- 客户直接参与
	- 自动化测试
	- 适应性计划调整
	- 结对编程
	- 测试驱动开发
	- 继续集成
	- 重构
- 适合小型项目，小步快跑
- 沟通、简单、反馈、勇气
- 快速反馈、简单性假设、逐步修改、提倡更改、优质工作
#### 需求分类与需求获取
- 分类
	- 业务需求
	- 用户需求
	- 系统需求
	- 功能需求
	- 性能需求
	- 设计约束（甲方要求用.net，用mysql等）
- QFD
	- 基本需求（甲方要求的）
	- 期望需求（希望得到的）
	- 兴奋需求（超预期的）
#### 结构化设计
- 自顶向下，逐步求精
- 信息隐蔽（函数封装，对外暴露参数）
- 模块独立（高内聚、低耦合、复杂度）
#### 软件测试
- 尽早，不断的进行测试
- 程序员避免测试自己设计的程序
- 既要选择有效、合理的数据，也要选择无效、不合理的数据
- 修改后应进行回归测试
- 尚未发现的错误数量与该程序已经发现的错误数量成正比
##### 静态测试
- 桌前检查
- 代码走查
- 代码审查
##### 动态测试
- 黑盒测试（看不见程序内部结构）
	- 等价类划分
	- 边界值分析
	- 错误推测
	- 因果图
- 白盒测试（覆盖率）
	- 基本路径测试
	- 循环覆盖测试
	- 逻辑覆盖测试
	
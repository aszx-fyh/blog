### 加密

对称加密：加密解密的密钥一样，公钥加密，私钥解密，（pdf，excel加密）
非对称：密钥不一样 （RSA），公钥可以随意传播，甲公钥加密，甲公钥解密。速度慢，不适合大量数据
信息摘要：保证信息完整性，无法篡改（算法：单向散列函数，单向hash函数。明文=>摘要，无法逆向）
数字签名：防抵赖，无法保密（发送方正文产生信息摘要用A的私钥加密=>接受方用A的公钥解密得到摘要并用正文产生摘要比对），摘要对称加密
数字信封：（与数字签名对比）用对方的公钥加密，对方可以用私钥解密，更安全
数字证书：传输过程中要证明人的身份，CA颁发数字证书（颁发机构的签名，持有者公钥信息）
设计邮件加密系统：
发送方（公钥：Ea, 私钥：Da）|  接收方（公钥：Eb, 私钥：Db）

邮件正文=>(随机密钥K)邮件密文   |   邮件密文=>（随机密钥K）邮件正文 ，关键是如何传递K
正文=>摘要=>（数字签名Da）摘要密文  |  摘要密文=>(Ea) 邮件摘要，对比正文生成的摘要
K=>(Eb)加密K |  加密K=>(Db)K

### 线性表

-  顺序表 用一维数组存储，连续空间

### 链表
离散空间，一个空间存数据和下一个元素的地址

- 单链表 头到尾
- 循环链表 尾巴指向头部，可以直接next操作到头部
- 双向链表 除了头和尾，中间的元素空间存上一个和下一个空间的地址
结点的删除、插入

### 双端队列

- 一端输入受限的双端队列
- 一端输出受限的双端队列
### 广义表
n个元素组成的有限序列，是线性表的推广
通常用递归的形式进行定义，记作 LS=(a0,a1,a2...,an)
n是长度，是最外层括号中的元素个数，括号重数为深度（嵌套次数）
操作：head(LS),tail(LS)
表头：第一个元素
表尾：除了第一个元素的其他元素组成的广义表

### 树

- 结点的度：孩子结点的数量
- 树的度：结点度数最高的度
- 叶子结点：没有孩子的结点
- 分支结点：有分支的结点
- 内部结点：除根节点和叶子结点
- 父结点：相对与子结点
- 子结点：相对于父结点
- 兄弟结点：相对的
- 层次：
### 二叉树
每个结点最多有2个子结点
1. 在二叉树的第i层上最多有2^(i-1)个结点（i>=1）
2. 深度为k的二叉树最有2^k-1个结点
3. 对于任何一棵二叉树，如果其叶子结点数为n0，度为2的结点数为n2，则n0=n2+1
4. 如果对一棵有n个结点的完全二叉树的结点按层序编号（从第1层到[log2n]+1层，每层从左到右），则对任一结点i(i<=i<=n),有
#### 满二叉树
　除最后一层无任何子[节点](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%25E8%258A%2582%25E7%2582%25B9)外，每一层上的所有结点都有两个子结点二叉树。
　　国内教程定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。
　　国外(国际)定义:a binary tree T is full if each node is either a leaf or possesses exactly two childnodes.大意为：如果一棵二叉树的结点要么是叶子结点，要么它有两个孩子结点，这样的树就是满二叉树。
#### 完全二叉树
1）只允许最后一层有空缺结点且空缺在右边，即叶子结点只能在层次最大的两层上出现；
2）对任一结点，如果其右子树的深度为j，则其左子树的深度必为j或j+1。 即度为1的点只有1个或0个

**满二叉树和完全二叉树编号可以用算法简单求出各个结点**
	  1
	 2     3
	4 5     6
	  7
	   8
层次遍历：按层次从左到右，12345678
前序遍历：先根后左再右，12457836
中序遍历：先左后根再右，42785136
后序遍历：先左后右再根，48752631
拆分子树不断遍历
#### 反向构造二叉树
根据某2个序列构造二叉树
#### 树转二叉树
孩子结点-左子树结点
兄弟结点-右孩子结点
连线法（兄弟结点连接，有多个子节点保留最左边的结点连线，断开其他，再旋转树）
#### 查找二叉树/排序二叉树
所有的左结点小于根结点，右结点大于根结点。有规律的排序可以提高查询速度
#### 最优二叉树（哈夫曼树）
- 树的路径长度 : 连接线的长度和
- 权：结点数值（某种字符出现的频度）
- 带权路径长度  ：结点路径长度x权
- 树的带权路径长度（树的代价）：叶子结点的带权路径长度和，最小则最优（哈夫曼树）`

#### 线索二叉树
普通二叉树叶子结点空了大量指针（没有子结点）
叶子结点加线索指向前驱节点和后驱结点
#### 平衡二叉树
为了提高查找效率。
- 任意结点的左右子树深度相差不超过1
- 没结点的平衡度只能为-1，0，1

树没有环，图有
### 图
- 无向图：连线没有箭头，邻接矩阵存储
- 有向图：连线有箭头，邻接表存储（首先把每个顶点的邻接顶点用链表示出来，然后用一个一维数组来顺序存储上面每个链表的头指针）
- 完全图：在无向图中，每对顶点都有一条线相连。在有向图中，每对顶点之间都有2条有向边互相连接

#### 图的最小生成树-普里姆算法/克鲁斯卡尔算法
边的路径总和最小，且不能形成环

### 算法
- 有穷性：执行有穷步之后结束
- 确定性：每一条指令都必须有确切的含义
- 输入 ：0个或以上的输入
- 输出 ：1个或以上的输出
- 有效性：每个步骤都有有效执行并能得到确定的结果。

#### 时间复杂度
常数级时间复杂度：O(1)
树查找：O(log2^n)
算法循环n次：O(n)
k层循环,每层循环k次：O(n^k)
O(2^n)
 空间复杂度：-

顺序查找：平均查找长度：(1+n)/2，时间复杂度：O(n)级别
二分查找：序列按顺序排列 ：最多次数为 的[log2^n]+1 ，时间复杂度为O(log2^n)
散列表查找：设计hash函数将给出key生成地址。设计一个好的hash函数需要减少冲突。

#### 排序
- 稳定与不稳定排序，稳定排序相同的键值顺序不会随机改变
- 内排序：内存里的排序
- 外排序：涉及到内存外的排序

1. 直接插入排序：插入一个已经排序的序列，一个个比较，找合适的位置
2. 希尔插入排序：（分组插入排序），n个元素，d1=n/2(取奇数)，d2=d1/2（取奇数），d3=d2/2（取奇数），直到d3=1，先多几轮排出大致顺序，再在最后一轮彻底排好。
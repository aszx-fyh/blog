## 内存
通常所说的内存指的是计算机的主存储器（main memory），简称主存。主存通过控制芯片等与CPU相连，主要负责存储指令和数据。主存通过可读写的元素构成，每个字节（1字节=8位）都带有一个地址编号。CPU可以通过改地址读取主存中的指令和数据，也可以写入数据。主存中的数据会随着电脑关机而消失。


### 堆和栈
 一个进程在执行的时候，它所占用的虚拟内存地址空间一般被分割成好几个区域，我们通常称为段（segment）。常见的几个段如下：
 - 代码段。编辑后的机器码存在的区域。一般是只读的。
 - bss段。存放未初始化的全局变量和静态变量的区域。
 - 数据段。存放有初始化的全局变量和静态变量的区域。
 - [函数调用栈](函数调用栈.md)（call stack）。存放函数参数，局部变量以及其他函数调用相关信息的区域。基于栈这样一个数据结构实现。具备“后入先出”的特点。
 - 堆（heap）。存放动态分配内存的区域，是无序的。
 每个线程都有一个栈，但是每一个应用程序通常都只有一个堆。在堆上的变量必须要手动释放，不存在作用域的问题。

 用户使用封装更好的“内存分配器”（Allocator）。如C语言runtime就提供了malloc和free这两个函数可以管理堆内存。
 - 栈上保存的局部变量在退出当前作用域的时候会自动释放。
 - 堆上分配的空间没有作用域，需要手动释放。
 - 一般栈上分配的空间大小是编译阶段就可以确定的。
 - 栈有个一个确定的最大长度，超过了这个长度会产生“栈溢出”（stack overflow）。
 - 堆的空间一般要更大一些，堆上的内存耗尽了，就会产生“内存分配不足”（out of memory）。

### 段错误segfault(segmentation fault)
segfault是这样形成的：进程空间中的每个段通过硬件MMU映射到真正的物理空间；在这个映射过程中，我们还可以给不同的段设置不同的访问权限，比如代码段就是只能读不能写。进程在执行过程中，如果违背了这些权限，CPU会直接产生一个硬件异常。硬件异常会被操作系统内核处理，一般内核会向对应的进程发送一条信号。如果没有实现自己特殊的信号处理函数，默认情况下，这个进程会直接非正常退出。如果操作系统打开了[core dump](core dump) 功能，在进程退出的时候系统会把它当时的内存状态，[寄存器](./寄存器)状态以及各种相关信息保存到一个文件中，提供用户以后调试使用。

 避免segfault方法
 - 使用标准代码来规范程序员的行为
 - 使用[自动垃圾回收机制](自动垃圾回收机制.md)。
 - **rust的主要设计目标之一，是在不用自动垃圾回收机制的前提下避免产生segfault。**

### 内存安全(memory safety)
 内存不安全的例子
- 空指针

解引用空指针是不安全的。这块地址空间一般是受保护的，对空指针解引用在大部分平台上会产生segfault。

- 野指针

野指针指的是未初始化的指针。它的值取决于它这个位置以前遗留下来的是什么值。所以它可能指向任意一个地方。对它解引用可能会造成segfault，也可能不会，纯粹凭运气。但无论如何，这个行为都不会是你预期内的行为，是一定会产生bug的。 

- 悬空指针

悬空指针指的是内存空间在被释放了之后，继续使用。它跟野指针类似，同样会读写不属于这个指针的内容。

- 使用未初始化内容
 
不只是指针类型，任何一种类型不初始化就直接使用都是很危险的，造成的后果我们完全无法预测。

- 非法释放

内存分配和释放要配对。如果对同一个指针释放两次，会制造出内存错误。如果指针并不是你内存分配器返回的值，对其执行释放操作，也是危险的。

- [缓冲区](缓冲区)溢出

指针访问越界了，结果也是类似于野指针，会读取或者修改临近内存空间的值，造成危险。

- 执行非法函数指针

如果一个函数指针不是准确地指向一个函数地址，那么调用这个函数指针会导致一段随机数据被当成指令来执行，是非常危险的。

- 数据竞争

在有并发的场景下，针对同一块内存同时读写，且没有同步措施。


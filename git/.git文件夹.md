.git 目录

### hooks（钩）

> 存放一些 shell 脚本

### Info:exclude

> 存放仓库的一些信息

### logs

> git 操作日志

### refs（refs：heads、remote）

> refs/heads 放仓库的分支信息,分支名做文件名，比如 master 文件，里面放 master 分支指向对象的 hash。每次 commit 都会更新
> tags

### index 文件

> git add 暂存的索引信息

### HEAD 文件

> HEAD 指针指向哪一个分支，如 ref: refs/heads/master，指向 master 分支

### description 文件

> 仓库的描述信息，主要给 gitweb 等 git 托管系统使用

### COMMIT_EDITMSG 文件

> git commit 提交的最新的注释信息

### ORIG_HEAD 文件

> 针对某些 危险操作 ，Git 通过记录 HEAD 指针的上次所在的位置 ORIG_HEAD 提供了回退的功能。当你发现某些操作失误了，比如错误的 reset 到了一个很早很早的版本，可以使用 git reset --hard ORIG_HEAD 回退到上一次 reset 之前。
> 每一次移动 HEAD 指针，Git 都会将移动的路径通过链表串起来，链表头部的 HEAD@{0}即 HEAD 指针。
> 但是 HEAD@{1}并不一定是 ORIG_HEAD！注意到，ORIG_HEAD 仅仅是当进行 危险操作 （比如 merge）时才会变更为 HEAD 指针的原值，而 HEAD@{}链表则记录了每次 HEAD 的移动（包括 commit）。
> git reflog 查看 HEAD@{}链表
> 显然，有了 reflog 命令后 HEAD 链表比不知道什么变过的 ORIG_HEAD 更好用，因此如果你使用的是 1.8.5 版本之后的 Git，推荐使用 HEAD{}链表来代替 ORIG_HEAD 指针。

### config 文件

> git 仓库的配置文件

### objects 文件夹（很重要）

> git add 会生成一个文件夹里面是此次 add 生成对象的 hash,内容是暂存区的文件内容快照

### 其他

> git 还提供了另一种排出的方式来做同样的事情，即在.git/info/exclude 这里设置的你要排出的文件。他不会影响到其他人，也不会提交到版本库中去。请注意与第一种方法的区别！

> .gitignore 还有个有意思的小功能，一个空的 .gitignore 文件可以当作是一个 placeholder。如当你需要为项目创建一个空的 log 目录时，这就变的很有用。使用方法：创建一个 log 目录在里面放置一个空的.gitignore 文件，当你 clone 这个 repo 的时候 git 会自动的创建好一个空的 log 目录了。

> 如果已经 git add 之后想删除某条记录，可以使用 git rm 来从记录文件里删除记录避免被 commit 执行。
> 删除以前提交的 commit，可 push push -f origin。
